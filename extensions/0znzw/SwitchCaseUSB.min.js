/**!
 * Switch Case (extension)
 * @author 0znzw <meow@miyo.icu> (@link https://scratch.mit.edu/users/0znzw/)
 * @version 1.3
 * @license MIT AND LGPL-3.0
 * Do not remove this comment
 * 
 * @todo Fix this in Unsandboxed.
 * @todo Fix this in the new compiler.
 */
!function(t){if(!t.extensions.unsandboxed)throw new Error('"Switch Case" must be ran unsandboxed.');"scaffolding"in window||(t.extensions.isUSB?alert("Unsandboxed is broken as of now :("):t.extensions.isPenguinMod&&alert("The compiler patches do not work in PenguinMod.\nThis extension may break at any time.\nDo not submit a bug report on PM."));const e="0znzwSwitchCaseUSB",{BlockType:s,ArgumentType:a,vm:c}=t,{runtime:n}=c;if(c.exports.these_broke_before_and_will_break_again)throw"scaffolding"in window||alert("GarboMuffins an ass so this doesnt work anymore lmfao."),"stub is not supported.";let r=t=>{};r=function t(e){if(t.patched)return;t.patched=!0;const s=e.constructor;s.getLoopFrame=function(t,e){const s=t.stackFrames;let a,c=null;for(let t=s.length-1;t>=0&&!(t<0);t--)if(s[t].isLoop||(e?s[t].isIterable:s[t].isBreakable||s[t].isIterable)){c=s[t].op.id,a=t;break}return!!c&&[c,a]},s.prototype.breakCurrentLoop=function(){const t=this.blockContainer,e=this.peekStackFrame();if(!e._breakData){let a=!1;if(!(a=s.getLoopFrame(this,!1)))return;const c=a[0],n=t.getBlock(c).next;e._breakData={loopFrameBlock:c,afterLoop:n}}const{loopFrameBlock:a,afterLoop:c}=e._breakData;let n;for(;(n=this.stack.at(-1))!==a;){if("procedures_call"===t.getBlock(n)?.opcode)return;this.popStack()}this.popStack(),c&&this.pushStack(c),delete e._breakData},s.prototype.continueCurrentLoop=function(){const t=this.blockContainer,e=this.peekStackFrame();if(!e._continueData){let t=!1;if(!(t=s.getLoopFrame(this,!0)))return;e._continueData=t[0]}let a;for(;this.stack[0]&&(a=this.stack.at(-1))!==e._continueData;){if("procedures_call"===t.getBlock(a)?.opcode)return;this.popStack()}this.status=s.STATUS_YIELD}};class i{constructor(){this.noFallthrough=!1}getInfo(){return{id:e,name:"Switch Case",blocks:[{blockType:s.REPORTER,opcode:"switchValue",text:"switch value",disableMonitor:!0},{blockType:s.REPORTER,opcode:"caseValue",text:"case value",disableMonitor:!0},"---",{blockType:s.CONDITIONAL,opcode:"switch",text:"switch [VALUE]",arguments:{VALUE:{type:a.STRING}},isBreakable:!0},{blockType:s.CONDITIONAL,opcode:"case",text:"case [VALUE]",arguments:{VALUE:{type:a.STRING}},isBreakable:!0},{blockType:s.CONDITIONAL,opcode:"default",text:"default",isTerminal:!0,isBreakable:!0},{hideFromPalette:!1,blockType:s.COMMAND,opcode:"break",text:"break",isTerminal:!0},{hideFromPalette:!1,blockType:s.COMMAND,opcode:"continue",text:"continue",isTerminal:!0},{blockType:s.XML,xml:t.extensions.isUSB?'<block type="control_break"></block><block type="control_continue"></block>':""}]}}static switch_value=`${e}_SwitchValue`;static case_value=`${e}_CaseValue`;static break_ran=`${e}_BreakRan`;static case_type=`${e}_IsCase`;static is_switch=`${e}_IsSwitch`;static frame_id=`${e}_FrameId`;static last_frame_did_not_break=`${e}_LastFrameDidntBreak`;static case_valid=`${e}_CaseValid`;static switch_construct=`${e}_SwitchConstruct`;static stack_construct=`${e}_StackConstruct`;_getParentFrame(t,e){const s=t.stackFrames.findIndex(t=>t?.op?.id===e);return(t.stackFrames[s-1]||{executionContext:{}}).executionContext}_getFrame(t,e){let s=null;for(let a=t.stackFrames.length-1;a>=0;a--){if(e(t.stackFrames[a])){s=a;break}}return null===s?{executionContext:{}}:t.stackFrames[s]}_getSwitchFrame(t){return this._getFrame(t,t=>t?.executionContext?.[i.is_switch]).executionContext}_getCaseFrame(t){return this._getFrame(t,t=>t?.executionContext?.[i.case_type]).executionContext}switch({VALUE:t},e){const s=e.thread;r(s);const a=e.stackFrame;void 0===a[i.is_switch]&&(a.isBreakable=!0,a[i.switch_value]=t,a[i.is_switch]=!0,a[i.case_type]=!1,a[i.last_frame_did_not_break]=null,e.startBranch(1,!1))}case({VALUE:t},e){const s=e.thread;r(s);const a=e.stackFrame,c=this._getParentFrame(s,s.peekStack());!c[i.is_switch]||this.noFallthrough&&c[i.last_frame_did_not_break]||(a[i.case_type]?c[i.last_frame_did_not_break]=!0:(a.isBreakable=!0,a[i.case_value]=t,a[i.case_type]="CASE",a[i.case_valid]=c[i.switch_value]===t,a[i.case_valid]||!this.noFallthrough&&c[i.last_frame_did_not_break]?(c[i.last_frame_did_not_break]=!1,e.startBranch(1,!0)):c[i.last_frame_did_not_break]=!0))}default(t,e){const s=e.thread;r(s);const a=e.stackFrame,c=this._getParentFrame(s,s.peekStack());if(c[i.is_switch]&&(a.isBreakable=!0,a[i.case_type]="DEFAULT",c[i.last_frame_did_not_break])){if(c[i.last_frame_did_not_break]=null,this.noFallthrough)return;e.startBranch(1,!1)}}break(t,{thread:e}){r(e),e.breakCurrentLoop()}continue(t,{thread:e}){r(e),e.continueCurrentLoop()}switchValue(t,{thread:e}){return this._getSwitchFrame(e)[i.switch_value]??""}caseValue(t,{thread:e}){return this._getCaseFrame(e)[i.case_value]??""}static JSG_getParentFrame(t){return this.frames[this.frames.findIndex(e=>e===t)-1]||{}}static JSG_getFrame(t){let e=null;for(let s=this.frames.length-1;s>=0;s--){if(t(this.frames[s])){e=s;break}}return null===e?{}:this.frames[e]}static JSG_getSwitchFrame(){return i.JSG_getFrame.call(this,t=>t[i.switch_value])}static JSG_getCaseFrame(){return i.JSG_getFrame.call(this,t=>t[i.case_value])}static JSG_descendForSource(t,e){const s=this.source;this.source="",this.descendStack(t,e);const a=this.source;return this.source=s,a}static JSG_checkStackConstruct(t){const e=t[i.stack_construct];e[0]&&(t[i.switch_construct].push(["raw",e.join("")]),t[i.stack_construct]=[])}static patchCompiler(){if(!c.exports.i_will_not_ask_for_help_when_these_break)return;const t=c.exports.i_will_not_ask_for_help_when_these_break();if(t.IntermediateStackedBlock)return;const{JSGenerator:s,ScriptTreeGenerator:a}=t,{Frame:r,TypedInput:o,TYPE_UNKNOWN:l}=s.unstable_exports,u=s.prototype,h=a.prototype,_=u.descendStackedBlock,d=h.descendStackedBlock,k=u.descendInput,p=h.descendInput;u.descendStackedBlock=function(...t){const s=t[0],a=i.JSG_getParentFrame.call(this,this.currentFrame);if(s.kind===`${e}.switch`){const t=this.localVariables.next(),a=n[`ext_${e}`].noFallthrough;this.currentFrame[i.is_switch]=!0,this.currentFrame[i.switch_value]=t,this.currentFrame[i.switch_construct]=[],this.currentFrame[i.stack_construct]=[],i.JSG_descendForSource.call(this,s.stack,new r(!1)),i.JSG_checkStackConstruct.call(this,this.currentFrame);const c=this.currentFrame[i.switch_construct],o=c.length;let l=`let ${t} = ${this.descendInput(s.value).asUnknown()}`,u="";this.currentFrame[i.is_switch]=!1;for(let e=0;e<o;e++){const[s,n]=c[e];if("default"===s)u+="default: {\n";else if("case"===s){const e=this.localVariables.next();l+=`, ${e}`,u+=`case (${t}): (${e} = (${this.descendInput(n.value).asUnknown()}));\ncase (${e}): {\n`,this.currentFrame[i.case_value]=e}else u+=`case (${t}): {\n`;const o=new r(!1);o.isBreakable=!0;u+=`${"raw"===s?n:i.JSG_descendForSource.call(this,n.stack,o)}${a&&"raw"!==s?"break;\n":""}};\n`}return this.currentFrame[i.is_switch]=!0,void(this.source+=`${l};\nswitch(${t}){\n${u}};\n`)}if(s.kind===`${e}.case`){if(!a[i.is_switch])return;return i.JSG_checkStackConstruct.call(this,a),void a[i.switch_construct].push(["case",s])}if(s.kind===`${e}.default`){if(!a[i.is_switch])return;return i.JSG_checkStackConstruct.call(this,a),void a[i.switch_construct].push(["default",s])}if(a[i.is_switch]){const t=new r(!1);t.isBreakable=!0;const e=i.JSG_descendForSource.call(this,[s],t);a[i.stack_construct].push(e)}else if(s.kind===`${e}.break`){if(!this.frames.find(t=>t.isLoop||t.isBreakable||t.isIterable))return null;this.source+="\nbreak;\n"}else{if(s.kind!==`${e}.continue`)return _.apply(this,t);if(!this.frames.find(t=>t.isLoop||t.isIterable))return null;this.source+="\ncontinue;\n"}},u.descendInput=function(...t){const s=t[0];if(s.kind===`${e}.switchValue`){const t=i.JSG_getSwitchFrame.call(this);return new o(t&&t[i.switch_value]||"",l)}if(s.kind===`${e}.caseValue`){const t=i.JSG_getCaseFrame.call(this);return new o(t&&t[i.case_value]||"",l)}return k.apply(this,t)},h.descendStackedBlock=function(...t){const s=t[0];return s.opcode===`${e}_switch`?{kind:`${e}.switch`,value:this.descendInputOfBlock(s,"VALUE"),stack:this.descendSubstack(s,"SUBSTACK")}:s.opcode===`${e}_case`?{kind:`${e}.case`,value:this.descendInputOfBlock(s,"VALUE"),stack:this.descendSubstack(s,"SUBSTACK")}:s.opcode===`${e}_default`?{kind:`${e}.default`,stack:this.descendSubstack(s,"SUBSTACK")}:s.opcode===`${e}_break`?{kind:`${e}.break`}:s.opcode===`${e}_continue`?{kind:`${e}.continue`}:d.apply(this,t)},h.descendInput=function(...t){const s=t[0];return s.opcode===`${e}_switchValue`?{kind:`${e}.switchValue`}:s.opcode===`${e}_caseValue`?{kind:`${e}.caseValue`}:p.apply(this,t)}}}i.patchCompiler(),t.extensions.register(n[`ext_${e}`]=new i)}(Scratch);