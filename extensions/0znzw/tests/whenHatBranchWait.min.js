/**!
 * Funny hat
 * @author 0znzw <meow@miyo.icu> (@link https://scratch.mit.edu/users/0znzw/)
 * @version 1.0
 * @license MIT AND LGPL-3.0
 * Do not remove this comment
 */
!function(t){if(!t.extensions.unsandboxed)throw new Error('"Funny hat" must be ran unsandboxed.');const n="0znzwWhenBoolHat2",e=(/**! Generated by patch generator. https://github.com/surv-is-a-dev/patch-generator */function(t){const n=t.vm.runtime;const e=n._convertBlockForScratchBlocks;n._convertBlockForScratchBlocks=function(n,o){const r=e.call(this,n,o);return!n.isTerminal||n.blockType!==t.BlockType.HAT&&n.blockType!==t.BlockType.EVENT||(r.json.nextStatement=void 0),r}}(t),t.vm);/**! THIS PATCH IS LICENSED UNDER MIT LICENSE **/t.extensions.register(new class{constructor(){this.funnyHatCond=Symbol(`${n}.FunnyHatPrevCondition`)}getInfo(){return{name:"Funny hat",id:n,blocks:[{opcode:"funnyhat",text:["when [COND] is | true:","false: | check every: [MS] ms"],branchCount:2,isTerminal:!0,blockType:t.BlockType.HAT,isEdgeActivated:!0,arguments:{COND:{type:null},MS:{type:t.ArgumentType.NUMBER,defaultValue:1e3}}}]}}spawnandwaitforthread(t,n){const o=n.thread.constructor,r=e.runtime._pushThread(t,e.editingTarget,{stackClick:!0,refreshMonitors:!1});return r.status===o.STATUS_DONE||new Promise(t=>{e.runtime.on("AFTER_EXECUTE",function n(){r.status===o.STATUS_DONE&&(e.runtime.off("AFTER_EXECUTE",n),t(!0))})})}sleep(t){return new Promise(n=>{setTimeout(()=>n(),t)})}async funnyhat({COND:n,MS:e},o){const r=o.thread,a=r.isCompiled?r.peekStack():r.peekStackFrame().op.id,s=r.target.blocks,c=s.getBlock(a);if(n!==c?.[this.funnyHatCond]){c[this.funnyHatCond]=n;const t=s.getBranch(a,1),e=s.getBranch(a,2);if(n){if(!t)return!1;await this.spawnandwaitforthread(t,o)}else{if(!e)return!1;await this.spawnandwaitforthread(e,o)}}return await this.sleep(t.Cast.toNumber(e)),!1}})}(Scratch);