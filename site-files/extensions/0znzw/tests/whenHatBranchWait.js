/**!
 * Funny hat
 * @author 0znzw https://scratch.mit.edu/users/0znzw/
 * @version 1.0
 * @license MIT AND LGPL-3.0
 * Do not remove this comment
 */
(function (Scratch) {
  if (!Scratch.extensions.unsandboxed) {
    throw new Error(`"Funny hat" must be ran unsandboxed.`);
  }

  const extId = '0znzwWhenBoolHat2';
  /* eslint-disable *//**! THIS PATCH IS LICENSED UNDER MIT LICENSE **/const patcher=((/**! Generated by patch generator. https://github.com/surv-is-a-dev/patch-generator */function(Scratch){const extId="0znzwWhenBoolHat2",PATCHES_ID=`__${extId}_patches__`,vm=Scratch.vm,runtime=vm.runtime;let exports;const _cbfsb=runtime._convertBlockForScratchBlocks;runtime._convertBlockForScratchBlocks=function(blockInfo,categoryInfo){const res=_cbfsb.call(this,blockInfo,categoryInfo);if(blockInfo.isTerminal&&(blockInfo.blockType===Scratch.BlockType.HAT||blockInfo.blockType===Scratch.BlockType.EVENT))res.json.nextStatement=undefined;return res};return exports;})(Scratch));/* eslint-enable */

  const vm = Scratch.vm;
  class extension {
    constructor() {
      this.funnyHatCond = Symbol(`${extId}.FunnyHatPrevCondition`);
    }
    getInfo() {
      return {
        name: 'Funny hat',
        id: extId,
        blocks: [{
          opcode: 'funnyhat',
          text: ['when [COND] is | true:', 'false: | check every: [MS] ms'],
          branchCount: 2,
          isTerminal: true,
          blockType: Scratch.BlockType.HAT,
          isEdgeActivated: true,
          arguments: {
            COND: { type: null },
            MS: { type: Scratch.ArgumentType.NUMBER, defaultValue: 1000 },
          }
        }]
      };
    }
    // Util functions
    spawnandwaitforthread(blockId, util) {
      const Thread = util.thread.constructor;
      const thread = vm.runtime._pushThread(blockId, vm.editingTarget, { stackClick: true, refreshMonitors: false });
      if (thread.status === Thread.STATUS_DONE) return true;
      return new Promise((resolve) => {
        vm.runtime.on('AFTER_EXECUTE', function afterExecute() {
          if (thread.status === Thread.STATUS_DONE) {
            vm.runtime.off('AFTER_EXECUTE', afterExecute);
            resolve(true);
          }
        });
      });
    }
    sleep(ms) {
      return new Promise((resolve) => {
        setTimeout(() => resolve(), ms);
      });
    }
    // Main block
    async funnyhat({ COND, MS }, util) {
      const thread = util.thread;
      const blockId = thread.isCompiled ? thread.peekStack() : thread.peekStackFrame().op.id;
      const blocks = thread.target.blocks;
      const block = blocks.getBlock(blockId);
      if (COND !== block?.[this.funnyHatCond]) {
        block[this.funnyHatCond] = COND;
        const branch1 = blocks.getBranch(blockId, 1);
        const branch2 = blocks.getBranch(blockId, 2);
        if (COND) {
          if (!branch1) return false;
          await this.spawnandwaitforthread(branch1, util);
        } else {
          if (!branch2) return false;
          await this.spawnandwaitforthread(branch2, util);
        }
      }
      await this.sleep(Scratch.Cast.toNumber(MS));
      return false;
    }
  }
  Scratch.extensions.register(new extension());
  // @ts-ignore
})(Scratch);
